"""GitHub Service for issue creation and management.

This service handles:
- Creating GitHub issues from draft specs
- Managing labels on issues
"""

import logging
from typing import Any

import httpx
import structlog

from src.core.config import settings

logger = structlog.get_logger(__name__)


class GitHubServiceError(Exception):
    """Base exception for GitHub service errors."""

    def __init__(self, message: str, details: dict[str, Any] | None = None) -> None:
        self.message = message
        self.details = details or {}
        super().__init__(self.message)


class GitHubService:
    """Service for interacting with GitHub API."""

    def __init__(
        self,
        token: str | None = None,
        repo: str | None = None,
    ) -> None:
        """Initialize the GitHub service.

        Args:
            token: GitHub API token (defaults to settings)
            repo: Repository in owner/repo format (defaults to settings)
        """
        self._token = token or settings.github_token.get_secret_value()
        self._repo = repo or settings.github_repo

        # Parse owner and repo from owner/repo format
        if "/" in self._repo:
            self._owner, self._repo_name = self._repo.rsplit("/", 1)
        else:
            raise GitHubServiceError(
                "Invalid repo format. Expected 'owner/repo'",
                {"repo": self._repo},
            )

        self._api_url = f"https://api.github.com/repos/{self._owner}/{self._repo_name}"

    @property
    def repo_url(self) -> str:
        """Get the repository URL."""
        return f"https://github.com/{self._owner}/{self._repo_name}"

    async def create_issue(
        self,
        title: str,
        body: str,
        labels: list[str] | None = None,
    ) -> str:
        """Create a GitHub issue.

        Args:
            title: Issue title
            body: Issue body (Markdown)
            labels: Optional list of labels to add

        Returns:
            The HTML URL of the created issue
        """
        # Append footer to body
        footer = "\n\n---\n*Generated by IterateSwarm*"
        final_body = f"{body}{footer}"

        # Deduplicate and filter labels
        if labels:
            unique_labels = list(set(labels))
        else:
            unique_labels = []

        payload = {
            "title": title,
            "body": final_body,
            "labels": unique_labels,
        }

        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    f"{self._api_url}/issues",
                    headers={
                        "Authorization": f"Bearer {self._token}",
                        "Accept": "application/vnd.github.v3+json",
                        "X-GitHub-Api-Version": "2022-11-28",
                        "Content-Type": "application/json",
                    },
                    json=payload,
                )

                if response.status_code == 201:
                    issue_data = response.json()
                    issue_url = issue_data.get("html_url")

                    logger.info(
                        "Created GitHub issue",
                        issue_number=issue_data.get("number"),
                        issue_url=issue_url,
                        title=title[:50],
                    )
                    return issue_url
                elif response.status_code == 401:
                    logger.error("GitHub authentication failed")
                    raise GitHubServiceError(
                        "GitHub authentication failed. Check API token.",
                        {"status": 401},
                    )
                elif response.status_code == 403:
                    logger.error("GitHub rate limit exceeded")
                    raise GitHubServiceError(
                        "GitHub rate limit exceeded. Try again later.",
                        {"status": 403},
                    )
                elif response.status_code == 404:
                    logger.error("GitHub repo not found")
                    raise GitHubServiceError(
                        f"Repository not found: {self._repo}",
                        {"status": 404},
                    )
                elif response.status_code == 422:
                    error_data = response.json()
                    logger.error(
                        "GitHub validation error",
                        errors=error_data.get("errors"),
                    )
                    raise GitHubServiceError(
                        "GitHub validation error",
                        {"status": 422, "errors": error_data.get("errors")},
                    )
                else:
                    logger.error(
                        "GitHub API error",
                        status_code=response.status_code,
                        response=response.text[:500],
                    )
                    raise GitHubServiceError(
                        f"GitHub API error: {response.status_code}",
                        {"status": response.status_code},
                    )

        except httpx.RequestError as e:
            logger.error(
                "GitHub request failed",
                error=str(e),
            )
            raise GitHubServiceError(f"Request failed: {e}") from e

    async def get_issue(self, issue_number: int) -> dict[str, Any] | None:
        """Get an issue by number.

        Args:
            issue_number: GitHub issue number

        Returns:
            Issue data or None if not found
        """
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(
                    f"{self._api_url}/issues/{issue_number}",
                    headers={
                        "Authorization": f"Bearer {self._token}",
                        "Accept": "application/vnd.github.v3+json",
                        "X-GitHub-Api-Version": "2022-11-28",
                    },
                )

                if response.status_code == 200:
                    return response.json()
                elif response.status_code == 404:
                    return None
                else:
                    response.raise_for_status()
                    return None

        except httpx.RequestError as e:
            logger.error(
                "Failed to get GitHub issue",
                issue_number=issue_number,
                error=str(e),
            )
            raise GitHubServiceError(f"Failed to get issue: {e}") from e

    async def close_issue(self, issue_number: int) -> bool:
        """Close an issue.

        Args:
            issue_number: GitHub issue number

        Returns:
            True if successful
        """
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.patch(
                    f"{self._api_url}/issues/{issue_number}",
                    headers={
                        "Authorization": f"Bearer {self._token}",
                        "Accept": "application/vnd.github.v3+json",
                        "X-GitHub-Api-Version": "2022-11-28",
                    },
                    json={"state": "closed"},
                )

                if response.status_code == 200:
                    logger.info(
                        "Closed GitHub issue",
                        issue_number=issue_number,
                    )
                    return True
                else:
                    response.raise_for_status()
                    return False

        except httpx.RequestError as e:
            logger.error(
                "Failed to close GitHub issue",
                issue_number=issue_number,
                error=str(e),
            )
            raise GitHubServiceError(f"Failed to close issue: {e}") from e

    def format_issue_body(
        self,
        content: str,
        source: str,
        feedback_id: str,
        reproduction_steps: list[str] | None = None,
        acceptance_criteria: list[str] | None = None,
        affected_components: list[str] | None = None,
    ) -> str:
        """Format issue body from spec data.

        Args:
            content: Original feedback content
            source: Source platform
            feedback_id: Feedback UUID
            reproduction_steps: List of reproduction steps
            acceptance_criteria: List of acceptance criteria
            affected_components: List of affected components

        Returns:
            Formatted Markdown body
        """
        body_parts = [
            f"**Source**: {source}",
            f"**Feedback ID**: {feedback_id}",
            "",
            "---",
            "",
            "## Original Feedback",
            content,
            "",
            "---",
            "",
        ]

        if reproduction_steps:
            body_parts.extend([
                "## Reproduction Steps",
                "",
            ])
            for i, step in enumerate(reproduction_steps, 1):
                body_parts.append(f"{i}. {step}")
            body_parts.append("")

        if acceptance_criteria:
            body_parts.extend([
                "## Acceptance Criteria",
                "",
            ])
            for criterion in acceptance_criteria:
                body_parts.append(f"- [ ] {criterion}")
            body_parts.append("")

        if affected_components:
            body_parts.extend([
                "## Affected Components",
                ", ".join(affected_components),
                "",
            ])

        return "\n".join(body_parts)


# Singleton for dependency injection
_github_service: GitHubService | None = None


def get_github_service() -> GitHubService:
    """Dependency injection for GitHubService.

    Returns:
        Singleton GitHubService instance
    """
    global _github_service
    if _github_service is None:
        _github_service = GitHubService()
    return _github_service
